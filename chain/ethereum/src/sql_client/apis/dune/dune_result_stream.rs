use graph::prelude::*;

use crate::sql_client::apis::dune::{DuneApi, ErrorResponse, GetExecutionResultResponse, BASE_URL};
use crate::sql_client::core::data::LogData;
use crate::sql_client::core::SqlClientError;
use graph::futures03::{FutureExt, Stream};
use std::collections::VecDeque;
use std::future::Future;
use std::task::{Context, Poll};

/// Represents the stream of all ExecutionResults generated by execute_query that is fetched from
/// get_execution_result endpoint.
pub struct DuneResultStream {
    state: ResultStreamState,
    ctx: ResultStreamContext,
}

pub enum ResultStreamState {
    /// The stream has just began or the last chunk fetched from get_execution_results was exhausted
    /// and the stream will make a request to fetch a new offset of results.
    BeginReconciliation { offset: i64 },

    /// The reconciliation request was made and the stream is waiting for its response.
    Reconciliation(
        Pin<Box<dyn Future<Output = Result<GetExecutionResultResponse, SqlClientError>> + Send>>,
    ),

    /// There reconciliation request has returned a list of results that are being yielded on the
    /// stream.
    YieldingResults {
        results: VecDeque<LogData>,
        /// The next offset to be fetched on reconciliation. If None, this is the last chunk.
        next_offset: Option<i64>,
    },

    /// The stream was exhausted.
    Finished,

    /// The stream has failed for some reason.
    Failed(SqlClientError),
}

/// Represents a cloneable context with information about how to fetch the next piece of data that can be cloned into async blocks.
pub struct ResultStreamContext {
    client: DuneApi,
    execution_id: String,
    // next_offset: Option<i64>,
}

impl Clone for ResultStreamContext {
    fn clone(&self) -> Self {
        Self {
            client: self.client.clone(),
            execution_id: self.execution_id.clone(),
        }
    }
}

impl ResultStreamContext {
    /// Returns a list of results from the endpoint to be yielded on the stream.
    async fn get_results(&self, offset: i64) -> Result<GetExecutionResultResponse, SqlClientError> {
        // let url = format!("{}/execution/{}/results/?offset={}", BASE_URL, self.execution_id, offset);
        let url = format!(
            "{}/execution/{}/results/?offset={}&limit=1000",
            BASE_URL, self.execution_id, offset
        );
        let req = self
            .client
            .reqwest
            .get(url)
            .header("x-dune-api-key", &ENV_VARS.dune_api_key);

        println!(
            "Fetching execution results from execution id {}",
            self.execution_id
        );
        let res = req.send().await?;
        let status = res.status();

        match status.is_success() {
            true => {
                let text = res.text().await?;
                let object: GetExecutionResultResponse = match serde_json::from_str(&text) {
                    Ok(object) => object,
                    Err(error) => return Err(SqlClientError::JsonDecodeError(error)),
                };
                Ok(object)
            }
            false => {
                eprintln!("Failed to fetch execution results from Dune.");
                let object: ErrorResponse = res.json().await.unwrap_or(ErrorResponse {
                    error: String::from(""),
                });

                Err(SqlClientError::ResponseError(status, object.error))
            }
        }
    }
}

impl DuneResultStream {
    pub fn new(client: DuneApi, execution_id: String) -> Self {
        Self {
            state: ResultStreamState::BeginReconciliation { offset: 0 },
            ctx: ResultStreamContext {
                client,
                execution_id,
            },
        }
    }
}

impl Stream for DuneResultStream {
    type Item = Result<LogData, SqlClientError>;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        loop {
            match &mut self.state {
                ResultStreamState::BeginReconciliation { offset } => {
                    let offset = offset.clone();
                    let ctx = self.ctx.clone();
                    let fut = async move { ctx.get_results(offset).await };
                    self.state = ResultStreamState::Reconciliation(fut.boxed());
                }
                ResultStreamState::Reconciliation(fut) => match fut.poll_unpin(cx) {
                    Poll::Ready(Ok(response)) => {
                        println!(
                            "Got {} rows from execution result",
                            response.result.rows.len()
                        );
                        self.state = ResultStreamState::YieldingResults {
                            results: VecDeque::from(response.result.rows),
                            next_offset: response.next_offset,
                        };
                    }
                    Poll::Pending => {
                        return Poll::Pending;
                    }
                    Poll::Ready(Err(error)) => {
                        eprintln!("Error getting execution results: {error:?}");
                        return Poll::Ready(None);
                    }
                },
                ResultStreamState::YieldingResults {
                    results,
                    next_offset,
                } => {
                    match results.pop_front() {
                        // If all the results from the current chunk has been yielded, check next_offset to know what to do next.
                        None => match next_offset {
                            None => self.state = ResultStreamState::Finished,
                            Some(offset) => {
                                self.state =
                                    ResultStreamState::BeginReconciliation { offset: *offset }
                            }
                        },
                        Some(result) => {
                            return Poll::Ready(Some(Ok(result)));
                        }
                    }
                }
                ResultStreamState::Failed(reason) => {
                    eprintln!("stream failed due to: {}", reason);
                    self.state = ResultStreamState::Finished;
                    return Poll::Ready(None);
                }
                ResultStreamState::Finished => {
                    return Poll::Ready(None);
                }
            };
        }
    }
}
